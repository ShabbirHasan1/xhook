{"version":3,"file":"xhook.min.js","sources":["../src/misc/array.js","../src/misc/window.js","../src/misc/events.js","../src/misc/event-emitter.js","../src/misc/headers.js","../src/patch/formdata.js","../src/misc/hooks.js","../src/patch/xmlhttprequest.js","../src/patch/fetch.js","../src/main.js"],"sourcesContent":["//if required, add 'indexOf' method to Array\nif (!Array.prototype.indexOf) {\n  Array.prototype.indexOf = function(item) {\n    for (let i = 0; i < this.length; i++) {\n      const x = this[i];\n      if (x === item) {\n        return i;\n      }\n    }\n    return -1;\n  };\n}\n\nconst slice = (o, n) => Array.prototype.slice.call(o, n);\n\nexport { slice };\n","let result = null;\n\n//find global object\nif (\n  typeof WorkerGlobalScope !== \"undefined\" &&\n  self instanceof WorkerGlobalScope\n) {\n  result = self;\n} else if (typeof global !== \"undefined\") {\n  result = global;\n} else if (window) {\n  result = window;\n}\n\n//find IE version\nconst useragent =\n  typeof navigator !== \"undefined\" && navigator[\"useragent\"]\n    ? navigator.userAgent\n    : \"\";\n\nexport let msie = null;\nif (\n  /msie (\\d+)/.test(useragent.toLowerCase()) ||\n  /trident\\/.*; rv:(\\d+)/.test(useragent.toLowerCase())\n) {\n  msie = parseInt(RegExp.$1, 10);\n}\n\nexport const windowRef = result;\nexport const documentRef = result.document;\n","import { documentRef } from \"./window\";\n\nexport const UPLOAD_EVENTS = [\"load\", \"loadend\", \"loadstart\"];\nexport const COMMON_EVENTS = [\"progress\", \"abort\", \"error\", \"timeout\"];\n\nconst depricatedProp = p =>\n  [\"returnValue\", \"totalSize\", \"position\"].includes(p);\n\nexport const mergeObjects = function(src, dst) {\n  for (let k in src) {\n    if (depricatedProp(k)) {\n      continue;\n    }\n    const v = src[k];\n    try {\n      dst[k] = v;\n    } catch (error) {}\n  }\n  return dst;\n};\n\n//proxy events from one emitter to another\nexport const proxyEvents = function(events, src, dst) {\n  const p = event =>\n    function(e) {\n      const clone = {};\n      //copies event, with dst emitter inplace of src\n      for (let k in e) {\n        if (depricatedProp(k)) {\n          continue;\n        }\n        const val = e[k];\n        clone[k] = val === src ? dst : val;\n      }\n      //emits out the dst\n      return dst.dispatchEvent(event, clone);\n    };\n  //dont proxy manual events\n  for (let event of Array.from(events)) {\n    if (dst._has(event)) {\n      src[`on${event}`] = p(event);\n    }\n  }\n};\n\n//create fake event\nexport const fakeEvent = function(type) {\n  if (documentRef && documentRef.createEventObject != null) {\n    const msieEventObject = documentRef.createEventObject();\n    msieEventObject.type = type;\n    return msieEventObject;\n  }\n  // on some platforms like android 4.1.2 and safari on windows, it appears\n  // that new Event is not allowed\n  try {\n    return new Event(type);\n  } catch (error) {\n    return { type };\n  }\n};\n","import { slice } from \"./array\";\nimport { mergeObjects, fakeEvent } from \"./events\";\n\n//tiny event emitter\nexport const EventEmitter = function(nodeStyle) {\n  //private\n  let events = {};\n  const listeners = event => events[event] || [];\n  //public\n  const emitter = {};\n  emitter.addEventListener = function(event, callback, i) {\n    events[event] = listeners(event);\n    if (events[event].indexOf(callback) >= 0) {\n      return;\n    }\n    i = i === undefined ? events[event].length : i;\n    events[event].splice(i, 0, callback);\n  };\n  emitter.removeEventListener = function(event, callback) {\n    //remove all\n    if (event === undefined) {\n      events = {};\n      return;\n    }\n    //remove all of type event\n    if (callback === undefined) {\n      events[event] = [];\n    }\n    //remove particular handler\n    const i = listeners(event).indexOf(callback);\n    if (i === -1) {\n      return;\n    }\n    listeners(event).splice(i, 1);\n  };\n  emitter.dispatchEvent = function() {\n    const args = slice(arguments);\n    const event = args.shift();\n    if (!nodeStyle) {\n      args[0] = mergeObjects(args[0], fakeEvent(event));\n    }\n    const legacylistener = emitter[`on${event}`];\n    if (legacylistener) {\n      legacylistener.apply(emitter, args);\n    }\n    const iterable = listeners(event).concat(listeners(\"*\"));\n    for (let i = 0; i < iterable.length; i++) {\n      const listener = iterable[i];\n      listener.apply(emitter, args);\n    }\n  };\n  emitter._has = event => !!(events[event] || emitter[`on${event}`]);\n  //add extra aliases\n  if (nodeStyle) {\n    emitter.listeners = event => slice(listeners(event));\n    emitter.on = emitter.addEventListener;\n    emitter.off = emitter.removeEventListener;\n    emitter.fire = emitter.dispatchEvent;\n    emitter.once = function(e, fn) {\n      var fire = function() {\n        emitter.off(e, fire);\n        return fn.apply(null, arguments);\n      };\n      return emitter.on(e, fire);\n    };\n    emitter.destroy = () => (events = {});\n  }\n\n  return emitter;\n};\n","//helper\nconst convert = function(h, dest) {\n  let name;\n  if (dest == null) {\n    dest = {};\n  }\n  switch (typeof h) {\n    case \"object\":\n      var headers = [];\n      for (let k in h) {\n        const v = h[k];\n        name = k.toLowerCase();\n        headers.push(`${name}:\\t${v}`);\n      }\n      return headers.join(\"\\n\") + \"\\n\";\n    case \"string\":\n      headers = h.split(\"\\n\");\n      for (let header of Array.from(headers)) {\n        if (/([^:]+):\\s*(.+)/.test(header)) {\n          name = RegExp.$1 != null ? RegExp.$1.toLowerCase() : undefined;\n          const value = RegExp.$2;\n          if (dest[name] == null) {\n            dest[name] = value;\n          }\n        }\n      }\n      return dest;\n  }\n  return [];\n};\n\nexport default { convert };\n","import { windowRef } from \"../misc/window\";\nimport { slice } from \"../misc/array\";\n\n//note:\n// we can patch FormData safely because all XHR\n// is hooked, so we can ensure the real FormData\n// object is used on send\n\n//browser's FormData\nvar Native = windowRef.FormData;\n\n//xhooks's FormData\nconst Xhook = function(form) {\n  this.fd = form ? new Native(form) : new Native();\n  this.form = form;\n  const entries = [];\n  Object.defineProperty(this, \"entries\", {\n    get() {\n      //extract form entries\n      const fentries = !form\n        ? []\n        : slice(form.querySelectorAll(\"input,select\"))\n            .filter(e => ![\"checkbox\", \"radio\"].includes(e.type) || e.checked)\n            .map(e => [e.name, e.type === \"file\" ? e.files : e.value]);\n      //combine with js entries\n      return fentries.concat(entries);\n    }\n  });\n  this.append = function() {\n    const args = slice(arguments);\n    entries.push(args);\n    return this.fd.append.apply(this.fd, args);\n  }.bind(this);\n};\n\n//patch interface\nexport default {\n  patch() {\n    if (Native) {\n      windowRef.FormData = Xhook;\n    }\n  },\n  unpatch() {\n    if (Native) {\n      windowRef.FormData = Native;\n    }\n  },\n  Native,\n  Xhook\n};\n","import { EventEmitter } from \"./event-emitter\";\n\n//global set of hook functions,\n//uses event emitter to store hooks\nconst hooks = EventEmitter(true);\n\nexport default hooks;\n","import { windowRef, msie } from \"../misc/window\";\nimport {\n  proxyEvents,\n  mergeObjects,\n  COMMON_EVENTS,\n  UPLOAD_EVENTS\n} from \"../misc/events\";\nimport { EventEmitter } from \"../misc/event-emitter\";\nimport headers from \"../misc/headers\";\nimport formData from \"./formdata\";\nimport hooks from \"../misc/hooks\";\n\nconst nullify = res => (res === undefined ? null : res);\n\n//browser's XMLHttpRequest\nconst Native = windowRef.XMLHttpRequest;\n\n//xhook's XMLHttpRequest\nconst Xhook = function() {\n  const ABORTED = -1;\n  const xhr = new Native();\n\n  //==========================\n  // Extra state\n  const request = {};\n  let status = null;\n  let hasError = undefined;\n  let transiting = undefined;\n  let response = undefined;\n  var currentState = 0;\n\n  //==========================\n  // Private API\n\n  //read results from real xhr into response\n  const readHead = function() {\n    // Accessing attributes on an aborted xhr object will\n    // throw an 'c00c023f error' in IE9 and lower, don't touch it.\n    response.status = status || xhr.status;\n    if (status !== ABORTED || !(msie < 10)) {\n      response.statusText = xhr.statusText;\n    }\n    if (status !== ABORTED) {\n      const object = headers.convert(xhr.getAllResponseHeaders());\n      for (let key in object) {\n        const val = object[key];\n        if (!response.headers[key]) {\n          const name = key.toLowerCase();\n          response.headers[name] = val;\n        }\n      }\n      return;\n    }\n  };\n\n  const readBody = function() {\n    //https://xhr.spec.whatwg.org/\n    if (!xhr.responseType || xhr.responseType === \"text\") {\n      response.text = xhr.responseText;\n      response.data = xhr.responseText;\n      try {\n        response.xml = xhr.responseXML;\n      } catch (error) {}\n      // unable to set responseXML due to response type, we attempt to assign responseXML\n      // when the type is text even though it's against the spec due to several libraries\n      // and browser vendors who allow this behavior. causing these requests to fail when\n      // xhook is installed on a page.\n    } else if (xhr.responseType === \"document\") {\n      response.xml = xhr.responseXML;\n      response.data = xhr.responseXML;\n    } else {\n      response.data = xhr.response;\n    }\n    //new in some browsers\n    if (\"responseURL\" in xhr) {\n      response.finalUrl = xhr.responseURL;\n    }\n  };\n\n  //write response into facade xhr\n  const writeHead = function() {\n    facade.status = response.status;\n    facade.statusText = response.statusText;\n  };\n\n  const writeBody = function() {\n    if (\"text\" in response) {\n      facade.responseText = response.text;\n    }\n    if (\"xml\" in response) {\n      facade.responseXML = response.xml;\n    }\n    if (\"data\" in response) {\n      facade.response = response.data;\n    }\n    if (\"finalUrl\" in response) {\n      facade.responseURL = response.finalUrl;\n    }\n  };\n\n  const emitFinal = function() {\n    if (!hasError) {\n      facade.dispatchEvent(\"load\", {});\n    }\n    facade.dispatchEvent(\"loadend\", {});\n    if (hasError) {\n      facade.readyState = 0;\n    }\n  };\n\n  //ensure ready state 0 through 4 is handled\n  const emitReadyState = function(n) {\n    while (n > currentState && currentState < 4) {\n      facade.readyState = ++currentState;\n      // make fake events for libraries that actually check the type on\n      // the event object\n      if (currentState === 1) {\n        facade.dispatchEvent(\"loadstart\", {});\n      }\n      if (currentState === 2) {\n        writeHead();\n      }\n      if (currentState === 4) {\n        writeHead();\n        writeBody();\n      }\n      facade.dispatchEvent(\"readystatechange\", {});\n      //delay final events incase of error\n      if (currentState === 4) {\n        if (request.async === false) {\n          emitFinal();\n        } else {\n          setTimeout(emitFinal, 0);\n        }\n      }\n    }\n  };\n\n  //control facade ready state\n  const setReadyState = function(n) {\n    //emit events until readyState reaches 4\n    if (n !== 4) {\n      emitReadyState(n);\n      return;\n    }\n    //before emitting 4, run all 'after' hooks in sequence\n    const afterHooks = hooks.listeners(\"after\");\n    var process = function() {\n      if (afterHooks.length > 0) {\n        //execute each 'before' hook one at a time\n        const hook = afterHooks.shift();\n        if (hook.length === 2) {\n          hook(request, response);\n          process();\n        } else if (hook.length === 3 && request.async) {\n          hook(request, response, process);\n        } else {\n          process();\n        }\n      } else {\n        //response ready for reading\n        emitReadyState(4);\n      }\n      return;\n    };\n    process();\n  };\n\n  //==========================\n  // Facade XHR\n  var facade = EventEmitter();\n  request.xhr = facade;\n\n  // Handle the underlying ready state\n  xhr.onreadystatechange = function(event) {\n    //pull status and headers\n    try {\n      if (xhr.readyState === 2) {\n        readHead();\n      }\n    } catch (error) {}\n    //pull response data\n    if (xhr.readyState === 4) {\n      transiting = false;\n      readHead();\n      readBody();\n    }\n\n    setReadyState(xhr.readyState);\n  };\n\n  //mark this xhr as errored\n  const hasErrorHandler = function() {\n    hasError = true;\n  };\n  facade.addEventListener(\"error\", hasErrorHandler);\n  facade.addEventListener(\"timeout\", hasErrorHandler);\n  facade.addEventListener(\"abort\", hasErrorHandler);\n  // progress means we're current downloading...\n  facade.addEventListener(\"progress\", function(event) {\n    if (currentState < 3) {\n      setReadyState(3);\n    } else if (xhr.readyState <= 3) {\n      //until ready (4), each progress event is followed by readystatechange...\n      facade.dispatchEvent(\"readystatechange\", {}); //TODO fake an XHR event\n    }\n  });\n\n  // initialise 'withCredentials' on facade xhr in browsers with it\n  // or if explicitly told to do so\n  if (\"withCredentials\" in xhr) {\n    facade.withCredentials = false;\n  }\n  facade.status = 0;\n\n  // initialise all possible event handlers\n  for (let event of Array.from(COMMON_EVENTS.concat(UPLOAD_EVENTS))) {\n    facade[`on${event}`] = null;\n  }\n\n  facade.open = function(method, url, async, user, pass) {\n    // Initailize empty XHR facade\n    currentState = 0;\n    hasError = false;\n    transiting = false;\n    //reset request\n    request.headers = {};\n    request.headerNames = {};\n    request.status = 0;\n    request.method = method;\n    request.url = url;\n    request.async = async !== false;\n    request.user = user;\n    request.pass = pass;\n    //reset response\n    response = {};\n    response.headers = {};\n    // openned facade xhr (not real xhr)\n    setReadyState(1);\n  };\n\n  facade.send = function(body) {\n    //read xhr settings before hooking\n    let k, modk;\n    for (k of [\"type\", \"timeout\", \"withCredentials\"]) {\n      modk = k === \"type\" ? \"responseType\" : k;\n      if (modk in facade) {\n        request[k] = facade[modk];\n      }\n    }\n\n    request.body = body;\n    const send = function() {\n      //proxy all events from real xhr to facade\n      proxyEvents(COMMON_EVENTS, xhr, facade);\n      //proxy all upload events from the real to the upload facade\n      if (facade.upload) {\n        proxyEvents(\n          COMMON_EVENTS.concat(UPLOAD_EVENTS),\n          xhr.upload,\n          facade.upload\n        );\n      }\n\n      //prepare request all at once\n      transiting = true;\n      //perform open\n      xhr.open(\n        request.method,\n        request.url,\n        request.async,\n        request.user,\n        request.pass\n      );\n\n      //write xhr settings\n      for (k of [\"type\", \"timeout\", \"withCredentials\"]) {\n        modk = k === \"type\" ? \"responseType\" : k;\n        if (k in request) {\n          xhr[modk] = request[k];\n        }\n      }\n\n      //insert headers\n      for (let header in request.headers) {\n        const value = request.headers[header];\n        if (header) {\n          xhr.setRequestHeader(header, value);\n        }\n      }\n      //extract real formdata\n      if (request.body instanceof formData.Xhook) {\n        request.body = request.body.fd;\n      }\n      //real send!\n      xhr.send(request.body);\n    };\n\n    const beforeHooks = hooks.listeners(\"before\");\n    //process beforeHooks sequentially\n    var process = function() {\n      if (!beforeHooks.length) {\n        return send();\n      }\n      //go to next hook OR optionally provide response\n      const done = function(userResponse) {\n        //break chain - provide dummy response (readyState 4)\n        if (\n          typeof userResponse === \"object\" &&\n          (typeof userResponse.status === \"number\" ||\n            typeof response.status === \"number\")\n        ) {\n          mergeObjects(userResponse, response);\n          if (!(\"data\" in userResponse)) {\n            userResponse.data = userResponse.response || userResponse.text;\n          }\n          setReadyState(4);\n          return;\n        }\n        //continue processing until no beforeHooks left\n        process();\n      };\n      //specifically provide headers (readyState 2)\n      done.head = function(userResponse) {\n        mergeObjects(userResponse, response);\n        setReadyState(2);\n      };\n      //specifically provide partial text (responseText  readyState 3)\n      done.progress = function(userResponse) {\n        mergeObjects(userResponse, response);\n        setReadyState(3);\n      };\n\n      const hook = beforeHooks.shift();\n      //async or sync?\n      if (hook.length === 1) {\n        done(hook(request));\n      } else if (hook.length === 2 && request.async) {\n        //async handlers must use an async xhr\n        hook(request, done);\n      } else {\n        //skip async hook on sync requests\n        done();\n      }\n      return;\n    };\n    //kick off\n    process();\n  };\n\n  facade.abort = function() {\n    status = ABORTED;\n    if (transiting) {\n      xhr.abort(); //this will emit an 'abort' for us\n    } else {\n      facade.dispatchEvent(\"abort\", {});\n    }\n  };\n\n  facade.setRequestHeader = function(header, value) {\n    //the first header set is used for all future case-alternatives of 'name'\n    const lName = header != null ? header.toLowerCase() : undefined;\n    const name = (request.headerNames[lName] =\n      request.headerNames[lName] || header);\n    //append header to any previous values\n    if (request.headers[name]) {\n      value = request.headers[name] + \", \" + value;\n    }\n    request.headers[name] = value;\n  };\n  facade.getResponseHeader = header =>\n    nullify(response.headers[header ? header.toLowerCase() : undefined]);\n\n  facade.getAllResponseHeaders = () =>\n    nullify(headers.convert(response.headers));\n\n  //proxy call only when supported\n  if (xhr.overrideMimeType) {\n    facade.overrideMimeType = function() {\n      xhr.overrideMimeType.apply(xhr, arguments);\n    };\n  }\n\n  //create emitter when supported\n  if (xhr.upload) {\n    let up = EventEmitter();\n    facade.upload = up;\n    request.upload = up;\n  }\n\n  facade.UNSENT = 0;\n  facade.OPENED = 1;\n  facade.HEADERS_RECEIVED = 2;\n  facade.LOADING = 3;\n  facade.DONE = 4;\n\n  // fill in default values for an empty XHR object according to the spec\n  facade.response = \"\";\n  facade.responseText = \"\";\n  facade.responseXML = null;\n  facade.readyState = 0;\n  facade.statusText = \"\";\n\n  return facade;\n};\n\nXhook.UNSENT = 0;\nXhook.OPENED = 1;\nXhook.HEADERS_RECEIVED = 2;\nXhook.LOADING = 3;\nXhook.DONE = 4;\n\n//patch interface\nexport default {\n  patch() {\n    if (Native) {\n      windowRef.XMLHttpRequest = Xhook;\n    }\n  },\n  unpatch() {\n    if (Native) {\n      windowRef.XMLHttpRequest = Native;\n    }\n  },\n  Native,\n  Xhook\n};\n","import { windowRef } from \"../misc/window\";\nimport { mergeObjects } from \"../misc/events\";\nimport hooks from \"../misc/hooks\";\nimport formData from \"./formdata\";\n\n//browser's fetch\nconst Native = windowRef.fetch;\n\n//xhook's fetch\nconst Xhook = function(url, options) {\n  if (options == null) {\n    options = { headers: {} };\n  }\n\n  let request = null;\n\n  if (url instanceof Request) {\n    request = url\n  } else {\n    options.url = url;\n  }\n\n  const beforeHooks = hooks.listeners(\"before\");\n  const afterHooks = hooks.listeners(\"after\");\n\n  return new Promise(function(resolve, reject) {\n    let fullfiled = resolve\n    const getRequest = function() {\n      if (options.body instanceof formData.Xhook) {\n        options.body = options.body.fd;\n      }\n\n      if (options.headers) {\n        options.headers = new Headers(options.headers);\n      }\n\n      if (!request) {\n        request = new Request(options.url, options);\n      }\n\n      return mergeObjects(options, request);\n    };\n\n    var processAfter = function(response) {\n      if (!afterHooks.length) {\n        return fullfiled(response);\n      }\n\n      const hook = afterHooks.shift();\n\n      if (hook.length === 2) {\n        hook(getRequest(), response);\n        return processAfter(response);\n      } else if (hook.length === 3) {\n        return hook(getRequest(), response, processAfter);\n      } else {\n        return processAfter(response);\n      }\n    };\n\n    const done = function(userResponse) {\n      if (userResponse !== undefined) {\n        const response = new Response(\n          userResponse.body || userResponse.text,\n          userResponse\n        );\n        resolve(response);\n        processAfter(response);\n        return;\n      }\n\n      //continue processing until no hooks left\n      processBefore();\n    };\n\n    var processBefore = function() {\n      if (!beforeHooks.length) {\n        send();\n        return;\n      }\n\n      const hook = beforeHooks.shift();\n\n      if (hook.length === 1) {\n        return done(hook(options));\n      } else if (hook.length === 2) {\n        return hook(getRequest(), done);\n      }\n    };\n\n    var send = () =>\n      Native(getRequest())\n        .then(response => processAfter(response))\n        .catch(function(err) {\n          fullfiled = reject\n          processAfter(err);\n          return reject(err);\n        });\n\n    processBefore();\n  });\n};\n\n//patch interface\nexport default {\n  patch() {\n    if (Native) {\n      windowRef.fetch = Xhook;\n    }\n  },\n  unpatch() {\n    if (Native) {\n      windowRef.fetch = Native;\n    }\n  },\n  Native,\n  Xhook\n};\n","import { EventEmitter } from \"./misc/event-emitter\";\nimport headers from \"./misc/headers\";\n\n//patchable types\nimport XMLHttpRequest from \"./patch/xmlhttprequest\";\nimport fetch from \"./patch/fetch\";\nimport FormData from \"./patch/formdata\";\n\n//global state\nimport hooks from \"./misc/hooks\";\n//the global hooks event emitter is also the global xhook object\n//(not the best decision in hindsight)\nconst xhook = hooks;\nxhook.EventEmitter = EventEmitter;\n//modify hooks\nxhook.before = function(handler, i) {\n  if (handler.length < 1 || handler.length > 2) {\n    throw \"invalid hook\";\n  }\n  return xhook.on(\"before\", handler, i);\n};\nxhook.after = function(handler, i) {\n  if (handler.length < 2 || handler.length > 3) {\n    throw \"invalid hook\";\n  }\n  return xhook.on(\"after\", handler, i);\n};\n\n//globally enable/disable\nxhook.enable = function() {\n  XMLHttpRequest.patch();\n  fetch.patch();\n  FormData.patch();\n};\nxhook.disable = function() {\n  XMLHttpRequest.unpatch();\n  fetch.unpatch();\n  FormData.unpatch();\n};\n//expose native objects\nxhook.XMLHttpRequest = XMLHttpRequest.Native;\nxhook.fetch = fetch.Native;\nxhook.FormData = FormData.Native;\n\n//expose helpers\nxhook.headers = headers.convert;\n\n//enable by default\nxhook.enable();\n\n\nexport default xhook;"],"names":["Array","prototype","indexOf","item","i","this","length","slice","o","n","call","result","WorkerGlobalScope","self","global","window","useragent","navigator","userAgent","msie","test","toLowerCase","parseInt","RegExp","$1","windowRef","documentRef","document","UPLOAD_EVENTS","COMMON_EVENTS","depricatedProp","p","includes","mergeObjects","src","dst","k","v","error","proxyEvents","events","event","e","clone","val","dispatchEvent","from","_has","fakeEvent","type","createEventObject","msieEventObject","Event","EventEmitter","nodeStyle","listeners","emitter","callback","undefined","splice","args","arguments","shift","legacylistener","apply","iterable","concat","on","addEventListener","off","removeEventListener","fire","once","fn","destroy","headers","h","dest","name","push","join","split","header","value","$2","Native","FormData","Xhook","form","fd","entries","Object","defineProperty","get","querySelectorAll","filter","checked","map","files","append","bind","patch","unpatch","hooks","nullify","res","XMLHttpRequest","xhr","request","hasError","transiting","response","status","currentState","readHead","statusText","object","getAllResponseHeaders","key","writeHead","facade","emitFinal","readyState","emitReadyState","responseText","text","responseXML","xml","data","responseURL","finalUrl","async","setTimeout","setReadyState","afterHooks","process","hook","onreadystatechange","responseType","readBody","hasErrorHandler","withCredentials","open","method","url","user","pass","headerNames","send","body","modk","beforeHooks","upload","setRequestHeader","formData","done","userResponse","head","progress","abort","lName","getResponseHeader","overrideMimeType","up","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","fetch","options","Request","Promise","resolve","reject","fullfiled","getRequest","Headers","processAfter","Response","processBefore","then","catch","err","xhook","before","handler","after","enable","disable"],"mappings":"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"}